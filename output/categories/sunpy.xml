<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Universe OpenAstronomy (Posts about SunPy)</title><link>http://openastronomy.org/Universe_OA/</link><description></description><atom:link href="http://openastronomy.org/Universe_OA/categories/sunpy.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 13 Aug 2020 01:54:15 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>GSOC 2020: New additions to old PRs</title><link>http://openastronomy.org/Universe_OA/posts/2020/08/20200811_1829_abhijeetmanhas/</link><dc:creator>Abhijeet Manhas</dc:creator><description>&lt;div&gt;&lt;h4&gt;GSOC 2020: Polishing my code&lt;/h4&gt;&lt;p&gt;I spent last most of the previous two weeks on resolving reviews on my old PRs and improving gallery examples.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/852/0*fsXbXhCmI6jKwUv6.jpg"&gt;&lt;figcaption&gt;Heavy rains begins in Vadodara&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;Knowing time intervals from URL patterns&lt;/h4&gt;&lt;p&gt;I created &lt;a href="https://github.com/sunpy/sunpy/pull/4419"&gt;PR #4419&lt;/a&gt; that allows getting file time-ranges from the URL using the scraper. The URL patterns from most of the archives have start time in them. Either the end time was usually hardcoded for all clients or we only used start time to validate the file URLs against a time interval.&lt;/p&gt;
&lt;p&gt;In my Clients Generalization, to escape this repetitiveness the code in post_search_hook() was somewhat less generalized. It was assumed that all files are day-long. Thus I generalized it and moved it to the scraper. From the base URL pattern, we can now the precision of time supported by the archive directories, and then using them we can find the end times. Say there are yearly files in an archive. Then we can default the end time to the end of that year. Moreover, if this time range overlaps with the searched time interval, the file is valid. We check it using _check_timerange().&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;h4&gt;Removed optional from class attributes&lt;/h4&gt;&lt;p&gt;We now need to register all ‘attrs’ supported by the client in PR #4321. This helped me to escape from defining optional attrs. We use register_values() only to know whether the client can serve the query or not.&lt;/p&gt;
&lt;h4&gt;Fido metadata queries Gallery Example&lt;/h4&gt;&lt;p&gt;I have added a new gallery example in &lt;a href="https://github.com/sunpy/sunpy/pull/4358"&gt;PR #4358&lt;/a&gt; which summarizes what we can do after the pull request is merged. We can make metadata queries and easily inspect them. A lot of minor improvements were also made in the PR.&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/08/20200811_1829_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/0e1004e2649bfd262dda2f4e37fed4a8/href"&gt;https://medium.com/media/0e1004e2649bfd262dda2f4e37fed4a8/href&lt;/a&gt;&lt;/iframe&gt;&lt;h4&gt;Extracting client responses from Fido result&lt;/h4&gt;&lt;p&gt;Earlier we have to specify index as an argument to get_response() to do that. It required us to count the records to find the correct index. Now we can easily use the name of the client to retrieve QueryResponse instances for that client. If there are multiple such records, then a list of all matching records will be returned.&lt;/p&gt;
&lt;h4&gt;ToDos for the final two weeks&lt;/h4&gt;&lt;p&gt;I have to document how to write Fido clients and add tests to the Fido metadata compatibility. Let’s see what other issues I can tackle in these pull requests.&lt;/p&gt;
&lt;p&gt;Till then,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAPRE NOCTEM!&lt;/strong&gt;&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=c2d1683fe428" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/08/20200811_1829_abhijeetmanhas/</guid><pubDate>Tue, 11 Aug 2020 17:29:54 GMT</pubDate></item><item><title>GSoC 2020: glue-solar project 3.1</title><link>http://openastronomy.org/Universe_OA/posts/2020/08/20200809_2322_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;The 3rd coding period of GSoC 2020 will officially conclude in 2 weeks time. I would like to take this opportunity to review the progress made thus far, and to outline what other major feature can be added to glue-solar, perhaps over the remaining 2 weeks and beyond.&lt;/p&gt;
&lt;p&gt;We have finally resumed code reviews for the remaining PRs in the glue repo, and I am happy to report that the PR dealing with adding a preferred_cmap attribute to the visual module of glue/core has been merged four days ago from today. This is a very memorable milestone as this is my first contribution to the glue codebase. The remaining PRs which are being worked on include the 1D Profile PR (&lt;a href="https://github.com/glue-viz/glue/pull/2156"&gt;PR #2156&lt;/a&gt;) as well as the wcs auto-linking PR (&lt;a href="https://github.com/glue-viz/glue/pull/2161"&gt;PR #2161&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Regarding our work at the glue-solar repo, all of the PRs reviewed except the two experimental ones has been merged. A User’s Guide and a Developer’s Guide have been added to the &lt;a href="https://glue-solar.readthedocs.io/en/latest/"&gt;docs&lt;/a&gt;, while there is one open WIP PR which I am working on to add both a contributing document and the code references (or API) for the repo. Also some docs introducing users on how to start their own extensions in glue-solar for conducting solar physics has been planned.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;All of the above will form the bulk of work to be submitted for the GSoC project.&lt;/p&gt;
&lt;p&gt;More can be done for glue-solar, including but not limited to the following:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Add NDData support to glue via glue-solar&lt;/li&gt;&lt;li&gt;Add instrument loader code from sunkit-instruments to glue-solar&lt;/li&gt;&lt;li&gt;Enable image / Movie exports, both with axes and without axes via matplotlib&lt;/li&gt;&lt;li&gt;Add support for pre-computed statistics in datasets / viewers.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Hopefully with the support of the mentors much of what has been planned can be brought to fruition, so that this project will be a successful one.&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=4aebd6964154" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/08/20200809_2322_kakirastern/</guid><pubDate>Sun, 09 Aug 2020 22:22:40 GMT</pubDate></item><item><title>Chapter 3 : The Search Events Object</title><link>http://openastronomy.org/Universe_OA/posts/2020/07/20200728_1932_raahul-singh/</link><dc:creator>Raahul Singh</dc:creator><description>&lt;div&gt;&lt;h4&gt;Chapter 3 : The Search Events Object&lt;/h4&gt;&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=ec306bbf6e51" width="1" height="1"&gt;
&lt;!-- TEASER_END --&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/07/20200728_1932_raahul-singh/</guid><pubDate>Tue, 28 Jul 2020 18:32:44 GMT</pubDate></item><item><title>GSOC 2020: Metadata searches using Fido</title><link>http://openastronomy.org/Universe_OA/posts/2020/07/20200728_1816_abhijeetmanhas/</link><dc:creator>Abhijeet Manhas</dc:creator><description>&lt;div&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/816/0*hF5ggLHngI8p-yaa"&gt;&lt;figcaption&gt;Missed Comet NEOWISE due to annoying cloud cover in Vadodara straight for 2 weeks :(&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;And that’s the central theme of the project :)&lt;/p&gt;
&lt;p&gt;It would now be possible to query clients that return metadata tables using Fido. So SunPy’s &lt;strong&gt;Fido&lt;/strong&gt; is a unified interface that allows searching and downloading solar physics data. In other words, it is a consistent and easy way to query most forms of solar physics data. It searches various archives and web services based on search attributes specified in the query.&lt;/p&gt;
&lt;p&gt;SunPy currently supports metadata facilities viz., JSOC Client, HEK Client, and Helio Client.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;SunPy’s hek module is used to access the information in the &lt;strong&gt;Heliophysics Event Knowledgebase&lt;/strong&gt; (HEK). HEK helps solar and heliospheric researchers locate features and events of interest.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Joint Science Operations Center&lt;/strong&gt; (JSOC) supports data products from various observatories and solar physics instruments.&lt;/p&gt;
&lt;p&gt;But they were not Fido compatible for metadata searches. PR #4358 addresses it.&lt;/p&gt;
&lt;h4&gt;Generic Class for metadata clients&lt;/h4&gt;&lt;p&gt;Since a lot of methods were similar in these clients, so I made a new superclass for them. JSOC, Helio, and HEK responses now inherit BaseQueryResponseTable to ease inspecting data retrieved through their clients. The idea was to retain the old look of response tables and also support a method to show all columns if required.&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/07/20200728_1816_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/abb67aed8bc120d39e874af9ef9ab599/href"&gt;https://medium.com/media/abb67aed8bc120d39e874af9ef9ab599/href&lt;/a&gt;&lt;/iframe&gt;&lt;h4&gt;Deprecations&lt;/h4&gt;&lt;p&gt;~sunpy.net.hek.attrs.Time is deprecated since we can now use ~sunpy.net.attrs.Time for HEK queries, making it redundant.&lt;/p&gt;
&lt;p&gt;I also deprecated ~sunpy.net.jsoc.attrs.Keys because now the response table contains all keys by default. Users can specify the column names as *args in :meth:~sunpy.net.hek.HEKResponse.show for getting an ~astropy.table.Table instance containing only those columns.&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/07/20200728_1816_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/d663f6878e23ecc59cd3f0b7cce932ef/href"&gt;https://medium.com/media/d663f6878e23ecc59cd3f0b7cce932ef/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;Finally, HEKTable was renamed to HEKResponse for consistency in naming.&lt;/p&gt;
&lt;h4&gt;Devguide for writing Fido Clients&lt;/h4&gt;&lt;p&gt;I have explained how to write a simple Fido client in &lt;a href="https://github.com/sunpy/sunpy/pull/4387"&gt;PR 4387&lt;/a&gt;. This was the first documentation pull request that I made in SunPy. Work is in progress for adding details of writing an “AttrWalker” and registring an “Attr” for Fido.&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/07/20200728_1816_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/449c51d6f6528dbb0a236344fe4a9524/href"&gt;https://medium.com/media/449c51d6f6528dbb0a236344fe4a9524/href&lt;/a&gt;&lt;/iframe&gt;&lt;h4&gt;Other Stuff&lt;/h4&gt;&lt;p&gt;I reviewed&lt;a href="https://github.com/sunpy/sunpy/pull/4394"&gt; PR #4394&lt;/a&gt;, which allows XRSClient to download reprocessed data for GOES Satellites. I also need to add support for this new pattern in my &lt;a href="https://github.com/sunpy/sunpy/pull/4321"&gt;dataretriever refactoring pull request, #4321&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I also go through the discussions present in the net issues so I can fit their fixes in my project. I also suggest updates to the description of outdated issues and check if they still persist, like in &lt;a href="https://github.com/sunpy/sunpy/issues/2401"&gt;Issue #2401&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/sunpy/sunpy/issues/2032"&gt;Issue #2032&lt;/a&gt; was fixed, so now helio wsdl_retriever returns the first valid taverna link.&lt;/p&gt;
&lt;p&gt;We are going to now enter the last phase of the work period!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CARPE NOCTEM!&lt;/strong&gt;&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=909bda98b771" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/07/20200728_1816_abhijeetmanhas/</guid><pubDate>Tue, 28 Jul 2020 17:16:19 GMT</pubDate></item><item><title>GSoC 2020: glue-solar project 2.2</title><link>http://openastronomy.org/Universe_OA/posts/2020/07/20200726_1213_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;The end of the 2nd Coding Period of this year’s Google Summer of Code has finally arrived. I cannot help but noticed the many things I have learned/built over the past two months for both the &lt;a href="http://glueviz.org/"&gt;glue&lt;/a&gt; Graphical User Interface (GUI), as well for its solar physics plugin glue-solar. One of the tricks I have learned is writing up tests for the GUI programming I have done in the process, which is using Qt for Python to port the entire &lt;a href="https://wiki.qt.io/PySide"&gt;PySide&lt;/a&gt; module to Qt5. My main approach is quite simple: Imitate, modify, test. Since glue has a fairly well developed codebase, it is not hard to find sample code snippets within it for inspiration of new code to add. The GUI unit tests are no exception to this rule. And, I would like to use the opportunity to share the experience with more novice contributors to the software, so perhaps somehow someone else somewhere down the line will be able to benefit from this.&lt;/p&gt;
&lt;p&gt;The first and foremost concern we should have regarding any type of unit testing is what we should check for functionality-wise. Let me take some code I have just written over the past few days which adds NDData (a data structure native to Astropy) support to glue and enables the loading of various types of astronomical data more readily, such as the standard FITS files. As I have discussed with my mentors via the glue-solar IRC channel, we have observed that NDData is much like laser was back in the 1960’s (e.g. as &lt;a href="https://www.nytimes.com/1964/05/06/archives/developer-of-the-laser-calls-it-a-solution-seeking-a-problem.html"&gt;reported by NYTimes&lt;/a&gt; then) was a solution in search of a problem before its wider adoption by the astronomy community for LSST, DKIST and CCDProc data. Now we are in the process of integrating it into glue. The original conception of this, at least in principle, is to use the simple and fluid structure of NDData to help process for example FITS data. This is because there are no generic NDData files in existence at all. This is to facilitate the manipulation of not only the data component, but also its units, mask, uncertainty, and meta attributes, which are quite common in the handling of astronomical data (pun intended). With such a motivation in mind, we have added a nddata.py module to the glue/core/data_factories directory in a &lt;a href="https://github.com/glue-viz/glue/pull/2164"&gt;PR&lt;/a&gt; at glue. To complete the PR, it is standard practice to add tests where applicable, so we have added a testing module called test_nddata.py in the glue/core/data_factories/tests directory to not only serve as a routine, but also to test whether the code has been properly debugged, which caught all of the major known bugs I have inadvertently introduced to the codebase before testing.&lt;/p&gt;
&lt;p&gt;The GUI unit test I have written is as follows:&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/07/20200726_1213_kakirastern/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/ba8b2229df9cf1b5b160c70096612af9/href"&gt;https://medium.com/media/ba8b2229df9cf1b5b160c70096612af9/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;I have studied the other tests in the same glue/core/data_factories/tests carefully before I proceed to write the code, as I have observed that the most basic test to write is to test the data loader. Of course, official docs helped me greatly as well. As for the formatted NDData factory, that would be hard to test. I will need to consult with my mentors, before deciding on whether a separate unit test for that later.&lt;/p&gt;
&lt;p&gt;One takeaway I have come away with in the process is that sufficient time is needed before I could brainstorm and come up with a tangible plan to write unit tests for any established codebase, and that I should not rush through the process. This is a lesson that I will definitely keep in mind. There is no use going through the motion and not enjoying the process as I go along, not to mention the omissions that I would make otherwise without a well thought-out plan.&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=db0e0ef935b2" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/07/20200726_1213_kakirastern/</guid><pubDate>Sun, 26 Jul 2020 11:13:28 GMT</pubDate></item><item><title>GSOC 2020: End of the First Half</title><link>http://openastronomy.org/Universe_OA/posts/2020/07/20200714_2212_abhijeetmanhas/</link><dc:creator>Abhijeet Manhas</dc:creator><description>&lt;div&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/0*L9pxwg-v0q0SppOR.jpg"&gt;&lt;figcaption&gt;Comet C/2020 F3 (NEOWISE) will be visible in India for the next 20 days!&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;So now I’m halfway through the Summer of Code Journey. The last two weeks have been full of code reviews, code refactoring, and documenting stuff. I also helped new contributors to the SunPy to get them started. Thus I interacted more with the community this time.&lt;/p&gt;
&lt;h4&gt;Making HEC Fido Compatible&lt;/h4&gt;&lt;p&gt;HEC stands for &lt;strong&gt;Heliophysics Event Catalogue&lt;/strong&gt;. For your information, Heliophysics events are a large variety of phenomena that:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;originate or occur on the Sun.&lt;/li&gt;&lt;li&gt;Propagate through the interplanetary medium.&lt;/li&gt;&lt;li&gt;Interact with the geospace and planetary analogs.&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/0*7_zVGR8NSlvJ4vOi.jpg"&gt;&lt;figcaption&gt;An illustration of an Heliophysics Event| Earth’s magnetic field shielding our planet from solar particles. Credit: NASA/GSFC/SVS&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;HEC allows complex searches for events stored in indexed catalogs. SunPy has a HECClient which allows you to interface with Helio web services.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;In &lt;a href="https://github.com/sunpy/sunpy/pull/4358"&gt;PR #4358&lt;/a&gt; to enable Helio metadata searches with Fido (Federated Internet Data Obtainer), I made it inherit ~sunpy.net.BaseClient and overwrote a few methods for the client. New hec-specific attrs like MaxRecords, TableName, and Catalogue were defined to make _can_handle_query() work.&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/07/20200714_2212_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/8cebddc67806c7e7130b0e70722fa975/href"&gt;https://medium.com/media/8cebddc67806c7e7130b0e70722fa975/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;A new class HECResponse was added to contain the responses retrieved after the search is executed. This made helio queries possible through Fido, although there are yet a lot of things that can be improved.&lt;/p&gt;
&lt;h4&gt;Updated tests for client redesign!&lt;/h4&gt;&lt;p&gt;&lt;a href="https://github.com/sunpy/sunpy/pull/4321"&gt;PR #4321&lt;/a&gt; (nice number!) is a major refactoring pull request for sunpy’s dataretriever module. So far it has negative 1500 lines of code.&lt;/p&gt;
&lt;p&gt;Finally SUVIClient was generalized which was the toughest of its counterparts. It supports the highest number of attributes. These are `Time`, Source, Instrument, Phsyobs, Provider, Level, Wavelength, and SatelliteNumber.&lt;/p&gt;
&lt;p&gt;The row data for the response table can either be contained as a dictionary or as data members of a class. A small hack made me achieve both. QueryResponseBlock was re-welcomed to the client.py. It now inherits OrderedDict and has dict values as class data members too. Passed Ordered Dictionary was used to update its self.__dict__.&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/07/20200714_2212_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/b8dae93e3cdf41797f7797b54de3573b/href"&gt;https://medium.com/media/b8dae93e3cdf41797f7797b54de3573b/href&lt;/a&gt;&lt;/iframe&gt;&lt;h4&gt;Other Stuff&lt;/h4&gt;&lt;p&gt;My mentor made a list of 38 issues in Sunpy that were related to the project. I went through all of them and labeled them based on the submodules they are concerned with, how much I understand them, and their relevance with the GSoC project. Some of them were overlapping with things in my mind, so existing discussions on them shall be really helpful for me.&lt;/p&gt;
&lt;p&gt;I also spent time on writing the guidelines to extend Fido and how to add new sources to it, based on the redesign.&lt;/p&gt;
&lt;p&gt;Looking forward to capturing the comet in the coming days and having an awesome second half!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CARPE NOCTEM!&lt;/strong&gt;&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=ec4589cc452f" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/07/20200714_2212_abhijeetmanhas/</guid><pubDate>Tue, 14 Jul 2020 21:12:28 GMT</pubDate></item><item><title>Detour: A Reflection</title><link>http://openastronomy.org/Universe_OA/posts/2020/07/20200714_1950_raahul-singh/</link><dc:creator>Raahul Singh</dc:creator><description>&lt;div&gt;&lt;h5&gt;Look at where we are, look at where we started.&lt;/h5&gt;&lt;p&gt;This post marks the halfway point of the GSoC journey. Instead of my usual full blown update posts, I want to celebrate this milestone with just a small, solemn reflection on the work we have accomplished so far.&lt;/p&gt;
&lt;p&gt;We have the Search Events up and running that maps the Sunspotter observation to the &lt;a href="https://www.lmsal.com/hek/"&gt;Heliophysics Events Knowledgebase (HEK)&lt;/a&gt;. This has broadened our dataset and will allow us to do timeseries analysis in the near future.&lt;/p&gt;
&lt;p&gt;We also have a Sunspotter class that handles the various CSVs and the AR FITS files.&lt;br&gt;
&lt;!-- TEASER_END --&gt;
The Sunspotter class allows us to rotate each observation to the nearest midnight, and convert observations from theHelioprojective frame to HeliographicStonyHurst frame.&lt;/p&gt;
&lt;p&gt;We have a few Neural Nets showing good prediction results.&lt;/p&gt;
&lt;p&gt;But all of these are technical details.&lt;/p&gt;
&lt;p&gt;What really has been a strangely new experience for me is the sense of collaboration. My mentors do not treat this as a project that I have to do and they have to guide. I’ve interacted with a lot of students from a lot of different orgs in the past few two and a half months. OpenAstronomy is different and unique in its sense of prioritising community.&lt;br&gt;
I know it’s a running theme, but I can’t find the words to describe how grateful I am, how exciting and fun this project has been because of my mentors and the SunPy community at large.&lt;br&gt;
Looking forward to the next half of the journey! :)&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=6da1c0609462" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/07/20200714_1950_raahul-singh/</guid><pubDate>Tue, 14 Jul 2020 18:50:42 GMT</pubDate></item><item><title>GSoC 2020: glue-solar project 2.1</title><link>http://openastronomy.org/Universe_OA/posts/2020/07/20200712_2340_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;The second coding period is now officially halfway through. Since the end of the first coding period, I have been working on both the &lt;a href="https://github.com/glue-viz/glue/pull/2156"&gt;1D Profile viewer&lt;/a&gt; and &lt;a href="https://github.com/glue-viz/glue/pull/2161"&gt;WCS autolinking&lt;/a&gt;. Since much has been discussed about the 1D Profile viewer of glue and now that it is finally working, let me take the opportunity to talk about the wcs-autolinking PR.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem statement&lt;/strong&gt;: Originally the wcs-autolinking only worked for some cases, for example for the spatial axes but not for the temporal and wavelength axes in the scenario where the dimensions of the two wcs objects of the data cubes being matched up do not match. This is highly undesirable and needs generalizing while conforming to &lt;a href="https://github.com/astropy/astropy-APEs/blob/master/APE14.rst"&gt;APE 14&lt;/a&gt;, where the issue of a shared Python interface for World Coordinate Systems is discussed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: So we rewrote the code. Most of the celestial code has been retained, with some new additions to add linking for the other dimensions. The code rewritten is as follows:&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;pre&gt;# Case for when the axes don't exactly match up&lt;br&gt;
if not forwards or not backwards:&lt;/pre&gt;&lt;pre&gt;    # A generalized APE 14-compatible way&lt;br&gt;
# Handle also the extra-spatial axes such as those of the time and wavelength dimensions&lt;/pre&gt;&lt;pre&gt;    if not wcs1.has_celestial or not wcs2.has_celestial:&lt;br&gt;
raise IncompatibleWCS("Can't create WCS link between {0} and {1}".format(data1.label, data2.label))&lt;/pre&gt;&lt;pre&gt;    try:&lt;br&gt;
wcs1_celestial = wcs1.celestial&lt;br&gt;
wcs2_celestial = wcs2.celestial&lt;br&gt;
wcs1_celestial_axis_physical_types = wcs1.celestial.world_axis_physical_types&lt;br&gt;
wcs2_celestial_axis_physical_types = wcs2.celestial.world_axis_physical_types&lt;br&gt;
print('wcs1.celestial.world_axis_physical_types', wcs1_celestial_axis_physical_types)&lt;br&gt;
print('wcs2.celestial.world_axis_physical_types', wcs2_celestial_axis_physical_types)&lt;br&gt;
except Exception:&lt;br&gt;
raise IncompatibleWCS("Can't create WCS link between {0} and {1}".format(data1.label, data2.label))&lt;/pre&gt;&lt;pre&gt;    cids1 = data1.pixel_component_ids&lt;br&gt;
cids1_celestial = [cids1[wcs1.wcs.naxis - wcs1.wcs.lng - 1],&lt;br&gt;
cids1[wcs1.wcs.naxis - wcs1.wcs.lat - 1]]&lt;br&gt;
slicing_axes_celestial1 = [cids1_celestial[0].axis, cids1_celestial[1].axis]&lt;br&gt;
slicing_axes_celestial1 = sorted(slicing_axes_celestial1, key=str, reverse=False)&lt;br&gt;
print('slicing_axes_celestial1', slicing_axes_celestial1)&lt;/pre&gt;&lt;pre&gt;    if wcs1_celestial.wcs.lng &amp;gt; wcs1_celestial.wcs.lat:&lt;br&gt;
cids1_celestial = cids1_celestial[::-1]&lt;/pre&gt;&lt;pre&gt;    cids2 = data2.pixel_component_ids&lt;br&gt;
cids2_celestial = [cids2[wcs2.wcs.naxis - wcs2.wcs.lng - 1],&lt;br&gt;
cids2[wcs2.wcs.naxis - wcs2.wcs.lat - 1]]&lt;br&gt;
slicing_axes_celestial2 = [cids2_celestial[0].axis, cids2_celestial[1].axis]&lt;br&gt;
slicing_axes_celestial2 = sorted(slicing_axes_celestial2, key=str, reverse=False)&lt;br&gt;
print('slicing_axes_celestial2', slicing_axes_celestial2)&lt;/pre&gt;&lt;pre&gt;    if wcs2_celestial.wcs.lng &amp;gt; wcs2_celestial.wcs.lat:&lt;br&gt;
cids2_celestial = cids2_celestial[::-1]&lt;/pre&gt;&lt;pre&gt;    # Collect all apparently matching axes in two lists for the two wcs objects being linked up&lt;br&gt;
wcs1_sliced_physical_types = wcs1_celestial_axis_physical_types&lt;br&gt;
slicing_axes1 = slicing_axes_celestial1&lt;br&gt;
wcs2_sliced_physical_types = wcs2_celestial_axis_physical_types&lt;br&gt;
slicing_axes2 = slicing_axes_celestial2&lt;br&gt;
for i, physical_type1 in enumerate(wcs1.world_axis_physical_types):&lt;br&gt;
for j, physical_type2 in enumerate(wcs2.world_axis_physical_types):&lt;br&gt;
if physical_type1 == physical_type2:&lt;br&gt;
if physical_type1 not in wcs1_sliced_physical_types:&lt;br&gt;
slicing_axes1.append(wcs1.world_n_dim - i - 1)&lt;br&gt;
wcs1_sliced_physical_types.append(physical_type1)&lt;br&gt;
if physical_type2 not in wcs2_sliced_physical_types:&lt;br&gt;
slicing_axes2.append(wcs2.world_n_dim - j - 1)&lt;br&gt;
wcs2_sliced_physical_types.append(physical_type2)&lt;/pre&gt;&lt;pre&gt;    slicing_axes1 = sorted(slicing_axes1, key=str, reverse=True)&lt;br&gt;
slicing_axes2 = sorted(slicing_axes2, key=str, reverse=True)&lt;/pre&gt;&lt;pre&gt;    print('slicing_axes1', slicing_axes1)&lt;br&gt;
print('slicing_axes2', slicing_axes2)&lt;/pre&gt;&lt;pre&gt;    print('wcs1_sliced_physical_types', wcs1_sliced_physical_types)&lt;br&gt;
print('wcs2_sliced_physical_types', wcs2_sliced_physical_types)&lt;/pre&gt;&lt;pre&gt;    # Generate slices for the wcs slicing&lt;br&gt;
slices1 = (slice(None),) * wcs1.world_n_dim&lt;br&gt;
slices2 = (slice(None),) * wcs2.world_n_dim&lt;/pre&gt;&lt;pre&gt;    slices1 = sorted(list(slices1))&lt;br&gt;
slices2 = sorted(list(slices2))&lt;/pre&gt;&lt;pre&gt;    for i in range(wcs1.world_n_dim):&lt;br&gt;
if i in slicing_axes1:&lt;br&gt;
pass&lt;br&gt;
else:&lt;br&gt;
slices1[i] = 0&lt;/pre&gt;&lt;pre&gt;    for i in range(wcs2.world_n_dim):&lt;br&gt;
if i in slicing_axes2:&lt;br&gt;
pass&lt;br&gt;
else:&lt;br&gt;
slices2[i] = 0&lt;/pre&gt;&lt;pre&gt;    wcs1_sliced = wcs1[tuple(slices1)]&lt;br&gt;
wcs2_sliced = wcs2[tuple(slices2)]&lt;/pre&gt;&lt;pre&gt;    cids1 = data1.pixel_component_ids&lt;br&gt;
cids1_sliced = [cids1[x] for x in slicing_axes1]&lt;br&gt;
cids1_sliced = sorted(cids1_sliced, key=str, reverse=True)&lt;/pre&gt;&lt;pre&gt;    cids2 = data2.pixel_component_ids&lt;br&gt;
cids2_sliced = [cids2[x] for x in slicing_axes2]&lt;br&gt;
cids2_sliced = sorted(cids2_sliced, key=str, reverse=True)&lt;/pre&gt;&lt;pre&gt;    pixel_cids1, pixel_cids2, forwards, backwards = get_cids_and_functions(&lt;br&gt;
wcs1_sliced, wcs2_sliced, cids1_sliced, cids2_sliced)&lt;/pre&gt;&lt;pre&gt;    self._physical_types_1 = wcs1_sliced_physical_types&lt;br&gt;
self._physical_types_2 = wcs2_sliced_physical_types&lt;/pre&gt;&lt;pre&gt;    if pixel_cids1 is None:&lt;br&gt;
raise IncompatibleWCS("Can't create WCS link between {0} and {1}".format(data1.label, data2.label))&lt;/pre&gt;&lt;p&gt;After checking with the tests written previously the code was modified before it is confirmed with pytest that all CI tests are now passing.&lt;/p&gt;
&lt;p&gt;Now we can link up wcs axes of the same physical types of two data cubes having different dimensions with no problems, illustrated as follows:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ffgo6t1M0ah9UcCyeLVdfg.png"&gt;&lt;/figure&gt;&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=620347ad3f8d" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/07/20200712_2340_kakirastern/</guid><pubDate>Sun, 12 Jul 2020 22:40:22 GMT</pubDate></item><item><title>GSoC 2020: glue-solar project 1.2</title><link>http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1911_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;It has been a month since GSoC’s coding period started early in June 2020. Much has happened since then in the glue-solar project, and to sum it up I have been pretty much spending all my GSoC time working on a WCSAxes-enabled version the 1D Profile viewer for extracting 1D spectrum from data cubes using the pixel extracted in a 2D Image viewer. To be honest it has been very effort-intensive, though not necessarily time-intensive as I have previously feared. But the journey has been fun given my very supportive and friendly project mentors. To the layman and non-specialist what I have related regarding the project details probably sounds esoteric, which it is. With this realization I will split this and remaining GSoC blog posts into two halves: one pertaining to my personal struggles, and the other pertaining to the technical aspect of the work carried out thus far, in that order, so that that latter part can be conveniently skipped over (but I do encourage you to do read both sections in tandem so get a better understanding of the project :-p) Anyway, let me begin…&lt;/p&gt;
&lt;h4&gt;Part 1: Personal struggles&lt;/h4&gt;&lt;p&gt;One personal “secret” I wish to reveal is that this is my last year as a PhD Candidate in Astrophysics at the University of Hong Kong (HKU). Not only that, since my Postgraduate Scholarship officially ran out in October 2019 and no other funding options are available, I have been holding down a job as a front-end developer for some parts of the weekdays to support my PhD studies. So far I have been trying to manage my time wisely and balancing my various duties and obligations as best as possible, but it has been a genuine struggle, especially in me trying to find enough time to sleep. To make matters worse I have a tendency to drift towards writing code than writing my thesis, though I am making progress in both. So I did hesitated to apply for GSoC for a 2nd time this year and was originally against the idea. But when I saw the project ideas available I changed my mind. Glue-solar is actually like a godsend for me; the project enabled me to not only further develop my self-discipline as a person, it also allowed me to learn from experts in the field working on open-source data visualization, and to grow from the experience. I thoroughly enjoyed interacted with my mentors, who have been very patient and helpful in offering me guidance (as well as friendship) throughout. If I have any advice I am allowed to offer anyone wanting to try out open-source software development through GSoC, and if GSoC does continue in the near future, I would recommend them to try out any of the OpenAstronomy projects. This is because OpenAstronomy is one (relatively) small but vibrant community of dedicated programmers, many of which scientists, that is welcoming to newcomers coming from a diverse background. And also, simply put, ASTRONOMY IS FUN! This is especially true for SunPy. I remember I started to contribute to open-source software as a relative novice with some bookish knowledge but not a lot of real-world experience back in around January 2019. My first contributions were to SunPy and Astropy. I remember I have read an article about how to get into GSoC in 2018 to learn about the program, though was not all that keen in getting into it at first. My first motivation to contribute was to give back to the community, because I had been using Python-based astronomy packages like Astropy for my PhD research. But at the urge of a mentor active in the Astropy community, I did apply. The GSoC project I worked on last year in 2019 was &lt;a href="https://summerofcode.withgoogle.com/archive/2019/projects/6094580905148416/"&gt;IRISpy&lt;/a&gt;, and my mentors were &lt;strong&gt;Dan Ryan&lt;/strong&gt; and &lt;strong&gt;Laura Hayes&lt;/strong&gt;. They were amazing as mentors, and were instrumental in my being able to complete the project successfully in the end of the program. I still miss my time spent with them on that project. IRISpy has officially changed its name to sunraster, which I was fortunate enough to help launch earlier this year in 2020. Basically when I was working on it as a GSoC project it was to provide additional functionalities for the analysis of observations from NASA’s Interface Region Imaging Spectrograph (IRIS) satellite which looks at UV emission from the solar chromosphere in particular. Now that scope has been extended to not just IRIS data, but data collected with similar instruments. This year I am using a lot of the code I have written for the IRISpy project for the current glue-solar project, which is kind of cool. As an icing to the cake, I get to work on data cubes for glue-solar, which is one of my favorite things in this world, a passion I have gained through my PhD research into integral field spectroscopy (IFS). For the present GSoC work I even get to work on &lt;strong&gt;4D data cubes (ones with an extra &lt;em&gt;time&lt;/em&gt; dimension)&lt;/strong&gt;, which has one more dimension than the IFS cubes I am so familiar with! So far it has been another incredible GSoC experience for me. All in all I have a feeling it will be a good one, and also a fruitful one.&lt;/p&gt;
&lt;h4&gt;Part 2: Technical aspect of progress made in glue-solar&lt;/h4&gt;&lt;p&gt;So we (me and my mentors) have ventured away from focusing on glue-solar and have entered the glue “proper” territory as we put more time and effort towards modifying the 1D Profile viewer. By this I mean we have begun work on glue instead of glue-solar as was the case as described in &lt;a href="https://medium.com/@krisastern/gsoc-2020-glue-solar-project-1-1-c2151e535e0c"&gt;my previous article&lt;/a&gt; where we have built a “SunPy Map” viewer. So I am well on my way to complete the task “modifying the existing glue 1D Profile viewer to provide sliders for extra dimensions (currently collapses)” soon, which is a significant part of the glue-solar project. Personally, I am really looking forward to working on the “adding support for pre-computed statistics in datasets / viewers” task, which I will surely make time to complete before end of August.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;Let me demonstrate how far we have come with the modification of the 1D Profile viewer. So ordinarily it is hard to get 4D data cubes with a time dimension. This can be fixed by stacking sequential (IRIS) raster scans/cubes. After firing up glue from the terminal by the magic command “glue”, and importing some if not all raster scans from the same observation using the IRIS OBS directory importer, and choosing to “Stack the sequential raster scans” , we see some data points appearing in the Data field of the GUI. This is illustrated by the sequence of images to follow:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5te3r5u7q5pxeWhiBv4x9Q.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 1.&lt;/strong&gt; Loading an multi-scan IRIS Observation and choosing to stack the sequential raster scans / cubes.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DvJ0gwjAKMjdGefNeggEpA.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 2.&lt;/strong&gt; Stacked datasets which are essentially 4D data cubes appear in the Data field of the glue-solar GUI.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*c1fcKBkCGbcibrc2nfU93w.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 3.&lt;/strong&gt; As per usual, choosing the 2D Viewer option will enable us to inspect the different sides of the N-dimensional or ND data cube.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*A_dQDmastlGwmif17b7J2Q.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 4.&lt;/strong&gt; Choosing the right (N-1) slices for the slicing to obtain the 1D profile (which I have learned in a hard way is not always the same as a 1D spectrum coding-wise) using some pre-defined logic that warrants some explanation, though should be intuitive to some.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Qq70FXHsyObzBniXG35BOQ.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 5.&lt;/strong&gt; Using the 1D Profile tool, as opposed to the red 1D spectrum button in the 2D Image viewer, to generate the desired profile, which may or may not be a 1D spectrum.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*FuXVHmy-MOFS-ELa6gFSUw.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 6.&lt;/strong&gt; Plotting of the uncollapsed version of the 1D profile by choosing the newly added “Slice” function which does nothing statistical to the data like the other functions such as “Maximum”, “Median”, and “Sum” that can be chosen as alternatives. (The default is “Maximum”).&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;As we can see in Figure 6, all 4 dimensions are represented in the 1D Profile viewer either as the x-axis or as a slider quantity. In this example, the x-axis is indeed wavelength (which yields a 1D spectrum by definition), the other dimensions are time, longitude (HPLN), and latitude (HPLT). Even though for now the sliders are still not yet functional and will need some tender loving care to make them work in tandem with the reference data as inherited or passed from the 2D Image viewer, which may take a few more days to complete, I believe this is truly a milestone in this GSoC project. If we can control the sliders to change the coordinate values, that would be a very useful tool in data exploration. I will spare the perhaps rather dry details regarding the reasoning through the whole thinking process that leads to this check point. However, I would like to explain the logic used in the slicing. What I have done is to introduced a SlicedData class, much like the existing IndexedData class that is used for pixel extraction with a tool my mentor &lt;strong&gt;Stuart Mumford&lt;/strong&gt; originally wrote for glue-solar (currently in a draft PR to be upstreamed to glue). First to pick a spatial coordinate, we choose in the 2D Image viewer the spatial axes for the image axes, selecting a point in the image shown on screen with the pixel selection tool, and then tweak the slider we would like its corresponding axis to be used as the x-axis in the 1D Profile viewer. Then we drag the same dataset to the viewing area and view using the 1D Profile viewer, in order to generate a profile for the slicing we have chosen. So this has been the work completed thus far. What is yet to be completed is to enable the manipulating of the 4D or higher dimensional data cube using the sliders for the same x-axis. So in the end regardless of the starting point, we could potentially use the 1D profile viewer to inspect the 4D or ND data cube in ways previously impossible before, at least to me.&lt;/p&gt;
&lt;p&gt;Again, I would like to thank my mentors for their guidance and support which enabled the progress I have made to happen. Much work will need to be done in order for the PRs to be polished up and merged later on in the summer. I really enjoy my glue-solar work for GSoC this summer. I hope you enjoyed reading this article as much as I had fun writing it too!&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=65ef40ba2b71" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1911_kakirastern/</guid><pubDate>Mon, 29 Jun 2020 18:11:30 GMT</pubDate></item><item><title>GSoC 2020: Generalization of Clients</title><link>http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1813_abhijeetmanhas/</link><dc:creator>Abhijeet Manhas</dc:creator><description>&lt;div&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/800/0*EsjuLxEt1BrtrdCG"&gt;&lt;figcaption&gt;Solar Eclipse 2020 in Vadodara, Gujarat (Lucky Enough to witness it this year!)&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;This fortnight, I worked around iterating over different designs for redesigning the Dataretriever Clients so that its implementation can be simpler and more general. Generalization here means the ability to inherit most of the methods from the base class itself; therefore minimizing a number of similar methods in the subclasses.&lt;/p&gt;
&lt;h5&gt;Show Method for QueryResponse&lt;/h5&gt;&lt;p&gt;I got&lt;a href="https://github.com/sunpy/sunpy/pull/4309"&gt; PR #4309&lt;/a&gt; merged which solved an old &lt;a href="https://github.com/sunpy/sunpy/issues/556"&gt;Issue #556&lt;/a&gt;. A simple show() function in ~sunpy.net.base_client.BaseQueryResponse enabled QueryResponse objects for Dataretriever, VSO, and JSOC clients to specify the columns to be shown in the result.&lt;/p&gt;
&lt;p&gt;This returns an ~astropy.table.Table instance, so table operations can also be easily performed on the result.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1813_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/10fce45866473f2eb6ad74e7f98000eb/href"&gt;https://medium.com/media/10fce45866473f2eb6ad74e7f98000eb/href&lt;/a&gt;&lt;/iframe&gt;&lt;h5&gt;_extract_files_meta method in Scraper&lt;/h5&gt;&lt;p&gt;&lt;a href="https://github.com/sunpy/sunpy/pull/4313"&gt;PR #4313&lt;/a&gt; was merged in sunpy:master that allows the scraper to extract the metadata stored in the file URLs. This function will prove very useful for refactoring the whole ~sunpy.net.dataretriever submodule.&lt;/p&gt;
&lt;p&gt;A new module parse was added in ~sunpy.extern which allowed to specify the extractor which will parse the file URL and return a dict containing the value of attrs like Wavelength, Time, Level, etc. Even the URL is returned by the method, which ensures no changes are to be made in fetch() methods for clients.&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1813_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/da15de642196febf9eab940219efac0f/href"&gt;https://medium.com/media/da15de642196febf9eab940219efac0f/href&lt;/a&gt;&lt;/iframe&gt;&lt;h5&gt;Playing with post filters&lt;/h5&gt;&lt;p&gt;Last fortnight I was working with post filters and concatenation of responses for VSO. Last week I dabbled a bit with post-filters for attrs used in all net clients. Using single_dispatch decorator over filter_results enabled post-filtering in dataretriver and VSO. It is pretty similar to the way it is done for ~sunpy.net.vso.attrs.&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1813_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/274b4e0b885d17b391589d15c593f046/href"&gt;https://medium.com/media/274b4e0b885d17b391589d15c593f046/href&lt;/a&gt;&lt;/iframe&gt;&lt;h4&gt;Redesigning GenericClient&lt;/h4&gt;&lt;p&gt;So there is a draft &lt;a href="https://github.com/sunpy/sunpy/pull/4321"&gt;PR #4321&lt;/a&gt; where work is in progress for the new implementation for the generalization. QueryResponeBlock is removed from the client.py since by few changes in the QueryResponse enables us to do it all using a dictionary. Similarly &lt;a href="https://github.com/sunpy/sunpy/pull/4321/files"&gt;a lot of methods were removed or changed&lt;/a&gt; under the aim to simplify the two Generic Classes.&lt;/p&gt;
&lt;p&gt;Not only the base class, even the client class were made simple. For simple clients, we are supposed to only define required attrs, optional attrs, a baseurl, and an extractor which makes the search working.&lt;/p&gt;
&lt;p&gt;After this refactoring, the example dataretriever source client class would look something like this:&lt;/p&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1813_abhijeetmanhas/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/759cceb1f744c525c6a55e80b8f9ecb9/href"&gt;https://medium.com/media/759cceb1f744c525c6a55e80b8f9ecb9/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;Only a class method and few class attributes are sufficient for defining a simple DR client!&lt;/p&gt;
&lt;h5&gt;Hooks for translating attrs&lt;/h5&gt;&lt;p&gt;There are some clients which deviate from generalization. For those clients, it was discussed in a meeting with mentors that post-hooks and pre-hooks for scraper are to be designed which shall perform a translation of attrs provided in the search to their representation in the url. While working around it, I discovered few bugs in fermi_gbm and other clients to be addressed in scraper hooks. Responses for Detector numbers 10 and 11 were never returned because in the url they were represented by na and nb respectively. They will be fixed by translators as a part of pre-hook before passing it to the scraper.&lt;/p&gt;
&lt;h5&gt;Moving Rhessi out from Generic&lt;/h5&gt;&lt;p&gt;Since rhessi didn’t follow the Generalization as the metadata can’t just be extracted from the file URL, so it is being implemented as subclass of base_client.&lt;/p&gt;
&lt;p&gt;Every week we move closer and closer to Generalization :). Enjoying the meetings where I and my mentors discuss the pros and cons of different designs of GenericClient!&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=1879f5dfe436" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1813_abhijeetmanhas/</guid><pubDate>Mon, 29 Jun 2020 17:13:52 GMT</pubDate></item></channel></rss>